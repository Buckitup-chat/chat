defmodule Chat do
  @moduledoc """
  High level functions
  """

  alias Chat.Db.Copying
  alias Chat.Ordering
  alias Chat.SignedParcel

  @doc """
  Updates a signed parcel by replacing `:next` placeholder indexes with actual numeric
  indexes generated by the Ordering module and written in DB. [Writes data in DB]

  ## Parameters
  - parcel: A SignedParcel struct containing data with :next placeholders

  ## Options
  - await: Whether to await for the parcel to be written into the database

  ## Returns
  - A new SignedParcel with proper numeric indexes
  """
  @spec store_parcel(%SignedParcel{}) :: %SignedParcel{}
  def store_parcel(%SignedParcel{} = parcel, opts \\ []) do
    processed_data =
      Enum.map(parcel.data, fn
        {{:dialog_message, dialog_hash, :next, message_id}, message} ->
          next_index = Ordering.next({:dialog_message, dialog_hash})
          {{:dialog_message, dialog_hash, next_index, message_id}, message}

        {key, value} ->
          {key, value}
      end)

    %SignedParcel{parcel | data: processed_data}
    |> tap(fn parcel ->
      Enum.each(parcel.data, fn {key, value} ->
        Chat.Db.put(key, value)
      end)
    end)
    |> tap(fn parcel ->
      if opts[:await] do
        Copying.await_written_into(parcel.data |> Enum.map(fn {key, _} -> key end), Chat.Db.db())
      end
    end)
  end

  @doc """
  Starts a task under Chat.TaskSupervisor that awaits for the parcel to be written
  in the database and then runs the provided function with the parcel.

  ## Parameters
  - parcel: A SignedParcel struct that has been stored
  - on_stored: A function that will be called with the parcel once it's written to DB

  ## Returns
  - The parcel (for chaining)
  """
  @spec run_when_parcel_stored(%SignedParcel{}, (SignedParcel.t() -> any())) :: %SignedParcel{}
  def run_when_parcel_stored(%SignedParcel{} = parcel, on_stored)
      when is_function(on_stored, 1) do
    Task.Supervisor.start_child(Chat.TaskSupervisor, fn ->
      keys = Enum.map(parcel.data, fn {key, _} -> key end)
      Copying.await_written_into(keys, Chat.Db.db())
      on_stored.(parcel)
    end)

    parcel
  end

  def db_get(key) do
    case key do
      {:file_chunk, file_key, first, last} -> read_chunk({first, last}, file_key)
      {:file_chunk, file_key, first} -> read_chunk(first, file_key)
      _ -> Chat.Db.get(key)
    end
  end

  def db_put(key, value) do
    Chat.Db.put(key, value)
    Copying.await_written_into([key], Chat.Db.db())
  end

  def db_has?(key) do
    case key do
      {:file_chunk, key, first, last} -> Chat.FileFs.has_file?({key, first, last})
      key -> Chat.Db.has_key?(key)
    end
  end

  defp read_chunk(range, key) when is_tuple(range) do
    {data, _last} =
      Chat.FileFs.read_exact_file_chunk(range, key, path())

    data
  end

  defp read_chunk(first, key) do
    Chat.FileFs.read_file_chunk(first, key, path())
  end

  defp path, do: CubDB.data_dir(Chat.Db.db()) <> "_files"
end
